# 虚拟机对象
## 一、对象创建
一个**普通对象**的创建，在java虚拟机中是如何创建的，

1. 遇见new关键字
2. 能否在常量池中定位到类符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。
3. 如果没有，那必须先执行相应的类加载过程。

## 二、内存分配

1. 假设内存是规整的，通过指针分界用过的内存和空闲内存，这种分配方式叫做“指针碰撞”（Bump the pointer）

2. 假设内存是不规整，通过维护一个列表来记性内存的分配，这种分配方式叫做“空闲列表”


选择哪种分配方式由java堆来决定，堆又是根据垃圾收集器是否具备压缩整理能力决定的，具备这种能力的就采用简单高效的指针碰撞，否则就只能使用空闲列表。  

对象创建的线程安全性问题，这个问题如何解决？

1. 通过同步处理来进行解决，具体虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性，但是多线程下频繁的运算会影响系统运行效率。

2. 给每块线程预先分配一小块内存，即本地线程分配缓冲，这种方式还有个名称TLAB（Thread Local AllocationBuffer），本地缓冲区用完的时候才通过第一步的同步处理来进行解决，是否使用TLAB可以通过-XX：+/-UseTLAB参数来设定，而tlab的每个线程的大小是根据采样算法得出的。

## 三、对象布局
对象布局分为三个部分：对象头、实例数据、对齐填充。
- 对象头：两种类型的数据，一种是存储GC年龄、hash码、持有锁的信息等等，另一种类型就是类型指针，通过这个指针可以确定是哪个类的实例。

- 实例数据：就是真正我们开发中使用的数据。

- 对齐填充：从名字就可以看出来，是为了补缺/补漏用的，这是因为hotspot虚拟机要求对象的起始地址必须是8字节的整数倍，对象头信息已经被精心设计为整数倍，但是实例数据存在不确定性，所以拿它来对齐，至于为什么这么设计，那肯定是为了提高空间利用率。


## 四、对象访问
对象访问分为句柄和直接访问，句柄无非就是在对象实例上面又抽象出的一层管理的空间，在句柄中指向了实际对象的地址，直接指向对象地址，没什么好说的把，就是直接访问指向。


需要注意的是，如果在栈中的指针指向了句柄，那么当对象的地址发生el变化，只需要在句柄中维护正确就好了，而不会影响到栈内的reference，反之，如果在栈内直接饮用了对象，那么对象位置发生变化需要将栈内的reference维护正确。

![](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20210702152322.png)