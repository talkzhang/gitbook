# 垃圾收集算法
> 再说垃圾收集算法之前，应该先了解如何判定对象是垃圾呢？

## 如何判定对象该回收（是垃圾）

### 引用计数法

即通过给对象天剑一个计数器，对象有被引用时数值就+1，引用失效时呢，数值-1，只要计数器的数值=0时说明这个对象肯定不能用了，该被回收了。
引用计数法肯定是简单高效，但是这个算法最坑的一方面就是比如出现循环引用时的计数失效问题，要解决这个问题需要做很多处理，在java hotspot内是没有使用这个算法的。

### 可达性分析算法

这个算法大致就是通过一系列的“GC Roots”来作为根节点，根节点的作用是什么呢？就是通过它来查看对象是否存在有效引用连，如果没有，则认为对象差不多该认为是垃圾去回收了。

GC Roots对象包括如下：

- 虚拟机栈中引用的对象。
- 类静态属性引用的对象。
- 常量引用的对象
- JNI引用的对象
- 虚拟机内部饮用，比如一些常用的异常（Nullpointerexception这种）、基本类型对应的class对象、以及系统类加载器等。
- 所有被同步锁持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。


### 驸：“引用”的概念

JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。 强引用：不回收； 软引用：描述还有用但非必须的对象。回收时内存紧张回收； 弱引用：在下次垃圾回收之前，无论内存是否紧张都会回收； 虚引用：不会对对象的生存时间造成任何影响，使用它的唯一目的只是为了能在这个对象进行垃圾回收时收到系统通知。 


## 对象回收步骤

1、在进行可达性分析算法之后筛选出来这些对象； 

2、判断此对象是否必要执行finalize()方法！如果对象没有覆盖finalize()方法或者finalize()已经被JVM调用过，则这个对象就会认为是垃圾，可以回收。 

3、如果出现覆盖finalize方法且没被调用过的这些对象，会被虚拟机放入F-QUEUE中，稍后由一个优先级为低调度的线程去执行，执行完之后（就是执行finalize方法），虚拟机对这个队列中进行二次标记，如果发现执行完finalize后又产生对象引用链，则将该对象移出“对象回收”集合，否则当作垃圾回收！ 


## 方法区回收

jdk1.8之后虽然方法区从永久代挪到了元空间，但是这部分内存对虚拟机来说，还是归它管理。 

方法区回收什么东西呢？ 

1. 废弃的常量。 
2. 不再使用的类型  
  2.1 该类所有的对象已被回收；  
  2.2 加载该类的类加载器已被回收；  
  2.3 该类的class对象没有在任何地方引用，即通过反射已无法获取该对象 因为现在有大量使用反射、动态代理等字节码框架（例如spring）会增加方法区的内存压力，所以这种情况下需要虚拟机支持类卸载的能力！ 

## 垃圾收集算法

基于分代理论，有“Minor GC”、“Major GC”、“Full GC”这样的回收类型。
- minor gc 回收新生代
- major gc 回收老年代
- full gc 回收新生代+老年代

垃圾回收算法主要包括标记-清除、标记复制、标记整理算法。

所有的算法都跳不过`标记`这一过程，所以可以说，垃圾回收算法基本上都是基于标记来进行算法操作的。

### 标记-清除

分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

标记过程就是对象是否属于垃圾的判定过程，这在上面[如何判定对象该回收/是垃圾](#如何判定对象该回收是垃圾)讲述垃圾对象标记判定算法时其实已经介绍过了。

标记清除是最基础的垃圾收集算法，别的算法都是基于这种思想来进行拓展设计界的，它的主要缺点：

1. 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低
2. 内存空间碎片化，清除之后产生了大量的不连续的内存碎片，标记、清除之后会产生大
量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找
到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![标记-清除算法示图](https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16091547922390.png)

### 标记-复制

为了解决标记清除法的效率问题，也就是在需要回收大量对象的时候的效率低下的问题，出现了标记复制算法，也可以叫做复制法。

它的主要工作原理是将可用内存分为大小相等的两块，每次都使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

如果内存中大多数对象都不需要回收，那这种算法就会产生较多的内存复制的开销，相反，如果需要复制的是少数的对象，效率还是很高的，这说明标记复制算法适用于对象频繁需要回收的场景。

而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效。

`缺点`也显而易见，就是将可用内存缩小到了原来的一般，资源浪费的有点过多。

![标记-复制图示](https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16115581754210.png)

hotspot虚拟机内将新生代分为Eden和Survivor区，其中survivor区有两个（实现了标记复制），它们的占比是8：1，也就是说在新生代有10%的空间会被浪费，毕竟新生代的对象回收率达到98%，但是这个数值并不是绝对，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，所以这里有`逃生门`的安全设计，当survivor区域无法容纳minor gc之后剩余的存活的对象时，就会依赖其他区域来进行分配担保，这个其他区域一般也就是老年代。

### 标记-整理

标记复制固然高效，但是它的空间浪费比较严重，且不太适用于存货大量对象的场景，会降低执行效率，且复制过程中，还要有分配担保机制保证它执行的安全性。

标记整理的原理：它的标记过程和标记-清除是一样的，只是标记-清除是对标记的对象进行内存清理，而标记-整理的操作是让所有存货的对象都向内存空间的一端移动。，然后直接清理边界以外的内存，`标记-清理`算法和`标记-整理`的区别是前者是非移动式的算法，而后者是移动式算法。

![标记-整理图示](https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16115608044721.png)

标记整理固然不错，但是它的缺点也很明显，在移动对象并更新引用这些对象的地方是一种极为负重的操作，这种操作需要停止别的所有线程的工作，也就是所谓的`stop the world`。

但是如果像标记-整理那样不对存活的对象进行移动操作的话，弥散于堆中的空间碎片化问题就需要得到解决，只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链表”来解决内存分配问题。这样的话说明业界内的确也有对标记清除算法的解决方式，但是如果不移动对象，势必要在内存分配时做更多复杂话操作，势必会直接影响应用程序的吞吐量。

所以这就取决于垃圾收集器更关注哪方面了，如果更关注吞吐量的话，那就在标记后进行对象的移动，但是这样可能会存在延迟问题（例如：Parallel Scavenge）；如果关注延迟问题，那就在分配对象时解决问题，但是这样会降低系统吞吐量（例如：CMS，ps：cms一般情况下使用标记清除，但是如果内存碎片影响到对象分配，则使用标记-整理收集一次）。

### java堆跨代引用如何回收处理

一张图说明一下

![java堆跨代引用回收处理](https://gitee.com/hongqigg/imgs-bed/raw/master/image/jvm%E5%A0%86%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E5%A4%84%E7%90%861.png)

例如新生代的`对象3`被老年代的某个对象引用时，为了方便GC roots扫描，新生代会有一钟数据结构`Remembered set`来进行跨代应用的记录，这样的减少了扫描整个老年代的代价，图中的A、B、C等区域是remembered set的逻辑分区，新生代进行垃圾回收时，存在跨代引用的对象，会查看`Remembered set`中记录的区域，然后扫描这个区域中是否还有引用链的存在，以满足可达性分析算法的Gc Roots条件来进行垃圾回收。


# 题外
## 如何查看jdk默认垃圾收集器
目前工作单位系统使用的垃圾收集器是1.8，命令**_java -XX:+PrintCommandLineFlags -version_**可以查看当前系统垃圾收集器使用情况。以我当前电脑环境配置为例：
```powershell
C:\Users\coolshell>java -XX:+PrintCommandLineFlags -version
-XX:InitialHeapSize=132172352 -XX:MaxHeapSize=2114757632 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
java version "1.8.0_261"
Java(TM) SE Runtime Environment (build 1.8.0_261-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)
```
可以看到**UseParallelGC**，使用了parallelGC， 即 **Parallel Scavenge + Parallel Old**，再查看详细信息，使用**_java -XX:+PrintGCDetails -version_**可以查看详细信息：
```powershell
C:\Users\coolshell>java -XX:+PrintGCDetails -version
java version "1.8.0_261"
Java(TM) SE Runtime Environment (build 1.8.0_261-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)
Heap
 PSYoungGen      total 38400K, used 2670K [0x00000000d5f80000, 0x00000000d8a00000, 0x0000000100000000)
  eden space 33280K, 8% used [0x00000000d5f80000,0x00000000d621bb30,0x00000000d8000000)
  from space 5120K, 0% used [0x00000000d8500000,0x00000000d8500000,0x00000000d8a00000)
  to   space 5120K, 0% used [0x00000000d8000000,0x00000000d8000000,0x00000000d8500000)
 ParOldGen       total 87552K, used 0K [0x0000000081e00000, 0x0000000087380000, 0x00000000d5f80000)
  object space 87552K, 0% used [0x0000000081e00000,0x0000000081e00000,0x0000000087380000)
 Metaspace       used 2302K, capacity 4480K, committed 4480K, reserved 1056768K
  class space    used 255K, capacity 384K, committed 384K, reserved 1048576K
```
