> 抱着一脸懵逼的表情，我拿起了《深入java虚拟机》看了起来，从开篇到现在，个人感觉书上内容还算容易理解，但是部分细节可能会理解有偏差，为防止以后踩坑，现将所认为重点笔记记录于此。
> 
# jvm内存模型

根据《java虚拟机规范》来换分jvm的区域的话主要有：

> **程序计数器、本地方法栈、虚拟机栈、方法区、堆。**


如图：

![jvm内存模型](https://gitee.com/hongqigg/imgs-bed/raw/master/image/341ef05061e750a9c16bed913bd32b2c.jpg)

从运行时分类，大致可以分为线程公有、线程私有两种类型。

1. 线程私有包括：程序计数器、虚拟机栈、本地方法栈。 
 
2. 线程公有包括：堆、方法区。


## 线程私有
### 程序计数器

1、是一块比较小的内存区域  
2、用来记录当前线程执行到的字节码行号  
3、由于只是用来记录行号，所以不存在内存溢出情况，是 JVM 内存区域中唯一一个没有定义 OutOfMemoryError 的区域  
4、每个线程都需要一个程序计数器用来记录执行哪行字节码，所以程序计数器是线程私有的  

### 虚拟机栈

1、每个方法调用时，线程都要为该方法创建一个栈帧，主要用来保存该函数的返回值、局部变量表（用于存放方法参数和方法内部定义的局部变量）动态连接、操作数栈（保存数据类型）等

2、当方法被调用时，栈帧在虚拟机栈中入栈，当方法执行完成时，栈帧出栈

3、一个线程中的方法调用可能会很长，很多方法处于执行状态。在线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧，该栈帧所关联的方法称为当前方法

4、虚拟机栈中，定义了两种异常：StackoverflowError：当线程调用的栈深度大于虚拟机允许的最大深度OutOfMemoryError：线程一只申请栈，直到内存不足（多数 Java 虚拟机允许动态扩展虚拟机栈的大小）

5、每个线程都对应一个虚拟机栈，因此虚拟机栈也是线程私有的

6、局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。

### 本地方法栈

和虚拟机栈的作用一样，只不过虚拟机栈执行的java方法，而本地方法栈执行的native方法，它也会抛出stackoverflowerror和outofmemoryerror。

## 线程共享
### java堆

1、用于存储对象实例，几乎所有的对象实例以及数组都在这里存储。2、Java堆是`垃圾收集器管理`的内存区域。3、如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。可以通过参数-Xmx和-Xms设定

### 方法区

1、在 Java 虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆

2、在 HotSpot（JDK 默认虚拟机实现） 中，将方法区当做永久代

3、方法区是各个线程共享的区域，用于存储全局变量、静态变量、常量、加载的类信息（包括版本、方法、接口等）等方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。

4、方法区在物理上也不要求是连续的，可以选择固定大小或可扩展大小

5、可以设置方法区是否进行垃圾回收

6、当内存不足时，方法区会抛出 OutOfMemoryError: PermGen space 异常

7、java8采用了元空间来替代永久代，因为永久代的存在有一个难以容忍的缺点：.永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，这样就会造成开发人员拿捏不准设置，或者忽略了该设置而导致oom。jdk6之后也就是jdk7，实现了将原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念。

8、相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。比如说类似spring框架应用字节码技术来动态生成代理类的这种框架，就需要虚拟机具备这种能力了。根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

#### 运行时常量池
这块区域，属于方法区，用来存放什么呢？用来存放编译期生成的各种字面量与符号引用，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是**String类的intern()方法**。

- String.intern()方法作用是什么？

这个方法是干什么用的呢，简单介绍一下：如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。

详情示例可查看美团技术团队博文，地址：[https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html](https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)

从string.intern方法可以看出jdk7之后将字符串常量池从防区挪到了堆内存中，所以同样的代码可能在jdk6和jdk7甚至之后的版本中有所差异，具体不做赘述。

## 直接内存 

**java从1.4引入NIO之后，可以通过native函数直接分配堆外内存，这样在一些场景中可以提高性能，因为避免了Java堆和native堆来回复制数据**，为什么呢？ 

使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。 堆内内存由JVM管理，属于“用户态”；而堆外内存由OS管理，属于“内核态”。如果从堆内向磁盘写数据时，数据会被先复制到堆外内存，即内核缓冲区，然后再由OS写入磁盘，使用堆外内存避免了这个操作。  

JVM虚拟机是运行在操作系统上的进程，操作系统分配给JVM的内存在启动是有限的，不可能把全部内存都分配给JVM，Java NIO又用到了直接内存技术，利用Channel和Buffer直接操作JVM外的内存，避免数据在JVM和操作系统内存之间来回复制。但是，当JVM和直接内存的和大于操作系统总内存时，就会发生内存溢出（oom）。

