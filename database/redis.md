# redis AOF持久化文件越来越大这么办？

这里不说rdb，就说AOF记录的是什么，AOF记录的是每次执行的所有命令行，所以AOF文件中的内容会越来越多，文件的体积也会越来越大，如果不加以控制的话，体积过大的 AOF文件很可能对Redis服务器、甚至整个宿主计算机造成影响，并且AOF文件的体积越大，使用AOF文件来进行数据还原所需的时间就越多

示例：

```bash
redis> RPUSH list "A" "B"          

结果：["A", "B"]

redis> RPUSH list "C"                        

结果：["A", "B", "C"]

redis> RPUSH list "D" "E"            

结果：["A", "B", "C", "D", "E"]

redis> LPOP list                     

结果：["B", "C", "D", "E"]

redis> LPOP list                     

结果：["C", "D", "E"]
```

为了解决AOF文件体积膨胀的问题，Redis提供了AOF文件重写（rewrite）功能，创建一个新的AOF文件来替代现有的AOF文件，新旧文件所保存的数据库状态相同，但新AOF文件不会包含任何冗余命令，所以体积会比旧的小得多

## aof重写实现原理

例如上面的例子，如果想要用尽量少的命令来记录list键的状态，那么最简单高效的办法不是去读取和分析现有AOF文件的内容，而是直接从数据库中读取键list的值，然后执行

```bash
RPUSH list "C" "D" "E" 
```

这一条命令就可以代替之前的5条命令，就可以将保存list键所需的命令从5条减少为一条了


首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令；可以对执行的一大堆命令行优化成更少条的命令，所以优化之后aof的文件体积肯定会小很多。

## aof后台重写

重写会进行大量的写入操作，会阻塞服务器线程，无法处理新的命令请求

为解决这个问题，Redis将AOF重写程序放到子进程里执行，这样，父进程就可以继续处理命令请求

但同时也会产生一个新的问题，子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而产生数据库状态不一致

为了解决数据不一致问题，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区在服务器创建子进程之后开始使用，当服务器执行完一个写命令之后，它会将这个写命令发送给AOF重写缓冲区

当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父进程在接到该信号之后，会调用信号处理函数，执行以下工作：

1）将AOF重写缓冲区中的所有内容写入到新AOF文件中，这时新AOF文件与当前的数据库状态一致

2）对新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换

在整个AOF后台重写过程中，只有信号处理函数执行时会对服务器造成阻塞

![](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20210628105601.png)