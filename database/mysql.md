# 事务四大特性
事务有四大特性，分别是原子性、一致性、隔离性、持久性。简称ACID；
* 原子性（Atomicity），可以理解为一个事务内的所有操作要么都执行，要么都不执行。
* 一致性（Consistency），可以理解为数据是满足完整性约束的，也就是不会存在中间状态的数据，比如你账上有400，我账上有100，你给我打200块，此时你账上的钱应该是200，我账上的钱应该是300，不会存在我账上钱加了，你账上钱没扣的中间状态。
* 持久性（Durability），指的是一个事务完成了之后数据就被永远保存下来，之后的其他操作或故障都不会对事务的结果产生影响。
* 隔离性（Isolation），指的是多个事务并发执行的时候不会互相干扰，即一个事务内部的数据对于其他事务来说是隔离的。

这里把隔离性放到最后说，为什么呢，在数据库操作中，为了有效保证并发读取数据的正确性，提出了事务隔离级别，我平平时所说的数据库锁基本上是针对隔离级别使用的，那什么是隔离级别呢，有哪些？什么是数据库锁，又有哪些？

# 数据库隔离级别

##  读未提交

意思就是说多个事务执行期间，事务之间可以以读到别的事务未提交的数据，即脏读现象。

脏读就是读到别的事务未提交的数据，无法保证数据的准确性。因为未提交有可能会发生rollback。

## 读已提交

是说一个事务如果没有完成提交之前，别的任何查询都不会查看待提交的数据，解决了脏读，存在不可重复读、幻读现象。是oracle、sqlserver默认的隔离级别。

## 可重复读

先说下不可重复读和幻读。

**不可重复读**：意思是，比如a事务select出某个账户余额100，这期间b事务扣减了10，那这时a事务再查这个账户余额发现和之前查的不一样，这种现象叫不可重复读；

**幻读是什么**：a事务查某个条件的数据，这期间b事务insert/delete了一条满足该条件的数据，a事务会发现数量和刚开始查询的并不一致了。

不可重复读针对更新操作，幻读针对添加和删除操作，在实际开发中，幻读和不可重复读程序中是可以接受的。

既然知道什么是不可重复读，那么可重复读就是可以避免不可重复读现象的发生，比如a事务select出某个账户余额100，这期间b事务扣减了10，那这时a事务再查这个账户余额发现和之前查的是一样的，也就是说我再怎么读也和我事务开启时是一样的。

那它是如何实现的？这得从数据库锁开始说起，首先从锁的控制思想角度来讲，数据库锁分为悲观锁和乐观锁。

### 悲观锁

说明是一种态度或者情绪，给人一样，每次无论读写操作，总是认为别得操作会过来一起修改，为了防止这种情况，每次操作都加锁，无非就是读锁、写锁，锁机制是通过数据库自己实现，传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

悲观锁缺点就是资源开销较大，它适用于写多读少的场景。

### 乐观锁

乐观锁认为别的任何操作不会更改，想法很乐观，认为这次的操作不会导致冲突，但在真正更新时，会去对比判断是否真的没有冲突。

乐观锁机制非常适合读多写少场景，通常我们可以利用这种思想去完成一些操作，比如账户扣减，我们可以先把当前账户信息查询出来，之后将账户的原金额作为条件去做更新操作。

mysql、oracle这种比较成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免可重复读和幻读问题，当然每个数据库实现的方式也有差别，我们是用的是mysql innodb引擎，所以只说myql是如何在可重复读隔离级别下解决可重复读、幻读问题。

### MVCC在innodb中的应用

在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值分别是当前行创建版本和删除版本号，它的实现逻辑规则：

* SELECT时，当前事务版本号>=读取创建版本号，当前事务版本号<删除版本号或除版本号为空。
* INSERT时，保存当前事务版本号为行的创建版本号
* DELETE时，保存当前事务版本号为行的删除版本号
* UPDATE时，首先update是先把当前更新的数据删除，然后插入一条新纪录，所以保存当前事务版本号为行的创建版本号，删除的原行呢，也会将当前事务版本号给记录下来。

通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。

### 说回来这个隔离级别

数据库的可重复读隔离级别下，可以利用MVCC机制生成一个查询快照，只要你开启了事务，那么会优先查看快照，不存在则去当前读。

快照读和当前读的区别就是，快照是读的某一个时刻的版本，当前读读的是实时的。

快照读就是普通的select....

当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。例如：

* select * from table where ? lock in share mode;
* select * from table where ? for update;
* insert;
* update ;
* delete;

读操作：

有这种机制在，举例某张表就一条数据 A事务查询select * 就能查到一条数据，且是当前事务版本号，b事务在a事务没完成期间插入了一条数据，并成功commit，那么A事务还是只查到一条数据。

写操作：

说写操作之前应该先说一下next-key锁，可重复提交利用这种机制可以避免幻读，什么是next-key锁呢？就是行锁+gap（间隙锁），那么什么是gap锁？首先mysql的数据结构是b+树，所有的键都在叶子节点上，那么这个叶子节点并且是有序的，间隙锁锁定的是节点与节点之间的位置，正如其名嘛。

同时会把<5的这个数据的索引的区间也给锁住，防止其他数据插入进来。这就是间隙锁锁定的位置区间。

我们说回写操作，比如某个字段是索引，它的值有1、3、5，事务A想要更新数据，更新条件是<5，在A事务提交之前，1、3两行数据会上行锁，这个没什么好说的，这时B事务想要插入一条2的数据，由于可重复读隔离级别下，mysql使用了next-key锁，这时2并作为间隙有锁，所以事务B会阻塞提交，就是等待A事务commit之后，B事务的插入动作才会执行，如果阻塞时间超时就会报lock wait timeout这种异常错误。

综上所述，mysql的可重复读隔离级别，在本地验证下呢，避免脏读的同时，也避免了不可重复读、幻读。不可重复读通过快照读避免，幻读通过next-key锁来实现。

你可能要说了，可重复读这不是挺牛的吗，为什么不使用可重复读呢？首先从实现角度来说确实做了很多优化，但是像幻读、不可重复读这种情况我们是完全可以接受的， 虽然可重复读隔离做了很多优化，但是和读已提交相比，快照读、间隙锁还是会增加系统开销，所以生产环境一般使用读已提交隔离级别。

## 序列化Serializable

这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。

# 数据库有哪些锁

从实现角度来说有悲观锁和乐观锁，上面又提到。

从落地方面来说有共享锁、排他锁、间隙锁。表锁。

**共享锁**

select ... lock in share mode.

共享锁是读锁，允许其他事务进行读操作，但不允许其他事务进行写操作。

**排他锁**

这就是所谓的写锁，不允许其他事务对已经获取写锁的数据进行读锁或者写锁。

**间隙锁**

上面有提到，可翻上复习。

**表锁**

就是把整张表都上锁，其他任何想要操作表的事务都获取不到锁。

**行锁**

行锁是一种上锁的称呼，行锁可以是排他锁，也可以是共享锁。

# mysql 为什么使用b+树

从数据库交互说起，数据库交互无非就是io操作，计算机存储设备一般分为两种：内存储器和外存储器，内存虽然很快但是没有持久性，所以数据库的数据都是存储在磁盘上的，而磁盘的读写速度取决于寻道时间、旋转延迟、传输时间三方面。寻道时间基本上市面上的磁盘一般在5ms以下，旋转延迟就是计算机磁盘转速，比如一个磁盘7200转，也就说说它一分钟能赚7200次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。基于这个例子，那访问一次数据库的时间就是大概9ms左右，数据库动辄上百万上千万数据，一次磁盘io需要9ms，所以io次数多会严重影响数据库读写效率，所以需要一套能够减少磁盘io交互的数据结构。

先说为什么不使用红黑树、或者平衡二叉树。主要原因是因为红黑树和平衡二叉树存储的节点高度会过高，毕竟二叉树每个节点只能有一个元素，且子节点只能有两个，对数据库数据来讲，成千上万的数据高度过高，每一层高度就要和磁盘打一次交道，这样会大大降低数据库效率，所以需要一种能在尽量少io操作的情况下就可以完成的一套数据结构。

再说b+树之前，先说下什么是b树，b的结构相对二叉树来讲，它最大特点就是每个节点可以存储多个元素，并且通过定义阶这个概念，可以拥有两个以上的子节点，当然b树有它详细的添加元素和删除元素的规则，这里不用赘述，使用b树可以大大降低树的高度，因为它可以多个元素，多个节点嘛。所以还是非常适合数据库这种与磁盘打交道的场景的，b树存储结构如图所示：

![b树存储结构](https://cdn.jsdelivr.net/gh/talkzhang/imgs-bed@master/image/20220309164414.png)

b树可以用于菲关系型数据库，比如mongodb。

说回来b+树，b+树是针对b树做了一些调整，使它更适合于关系型数据库，具体调整有

1.非叶子节点中每个元素不保存数据，只用来索引，所有数据都保存在叶子节点；这样在索引数据时，比如mysql每次查询数据按页查询，它的默认值是16kb，每次容量上限相同的查询情况下，b+树一次io会比b树查询出更多的键值。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接，所以非常适合范围查找，而b树要完成范围查找，则需要跨树层中序遍历，增加了io，效率相对较低。

其次，b+树所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素，b树是各管各的，不存在这种规则；

b+树存储结构图：

![b+树存储结构](https://cdn.jsdelivr.net/gh/talkzhang/imgs-bed@master/image/20220310114239.png)

参考连接：https://www.cnblogs.com/lianzhilei/p/11250589.html

# mysql查询过程是什么样的

1. 首先客户端向服务端请求，获取连接，要经过连接器，连接器会对这些连接进行管理，比如不能超过最大链接数这种异常就是这里抛出的
2. 查询是否缓存命中，当然这个一般是不会用的，对系统的消耗代价比较高，综合性价比很低的，因为缓存会带来额外的操作，所以一般我们数据库都是关闭状态
3. 解析器，将编写的sql进行优化，比如联合索引这种情况下，优化你的sql内的顺序
4. 调用存储引擎进行操作，完成增删改查
5. 将结果返回客户端。

# 为什么varchar建立长度要评估具体使用字符

varchar字段创建时时需要指定所需长度，varchar在磁盘上的实际存储是按实际字符来存储的，既然这样那为什么还要指定长度时评估呢，从两方面来讲，第一首先是内存操作，对于 varchar 数据类型来说，硬盘上的存储空间虽然都是根据实际字符长度来分配存储空间的，但是对于内存来说，则不是。内存其实使用固定大小的内存块来保存值。简单的说，就是使用字符类型中定义的长度，即 1000或者100（自定义的长度） 个字符空间。显然，这对于排序或者临时表(这些内容都需要通过内存来实现)作业会产生比较大的不利影响；第二方面，从索引角度来讲，MySQL建立索引时假设没有限制索引的大小，索引长度会默认采用的该字段的长度。也就是说 varchar(1000) 的索引比 varchar(100) 的大。

# varchar与char的区别是什么？

varchar(m)是可变长度，就是varchar它存储时磁盘按它的实际长度进行存储，同时采用额外的 1 ~ 2 个字节记录实际长度，当实际长度小于等于 255 时，额外占用 1 个字节去存储实际长度，大于 255 时，则额外使用 2 个字节；char(m)是固定长度，而char如果不够定义的长度则按空格补齐，查询时将尾部所有空格去除（包括本来数据就有的空格，很坑吧）;

# mysql多个索引是如何存储的

就说innodb引擎，因为我们通常使用的是innodb，首先会为每张表以b+树的形式创建聚簇索引，该表会将主键和数据保存在一张表内，表内如果没有主键则innodb会找寻一个唯一索引来作为聚簇索引的键值，如果没有唯一索引，则会隐式使用数据行号来作为主键，在聚簇索引的基础上，可能会有别的字段也创建了索引，那这些索引也会以b+树的形式进行存储，这些索引的非叶子节点键值就是对应的索引值，而叶子节点的data值就是之前提到的主键索引，然后在通过找到的主键去聚簇索引内找寻具体的数据，所以，索引的存储也是以b+树的方式存储的。

# 为什么不建议字段过长

因为mysql每次在磁盘与内存之间打交道是有固定页的大小来交互的，字段的长度会作为一个单位计算在交互时的页内存中，比如一个字段varchar，通常10个以内字符就够了，但是当你给100长度时，虽然对于磁盘来讲，占用存储空间都不变，但是对于数据库查询时来讲，会降低数据库查询效率，你想啊，这个单位大了，那么以b+树的结构与磁盘打交道时，每次页内存中的数据就会减少，也就会增加io次数，所以降低了效率。

# MongoDB为什么使用B树不用b+树

从根本上来讲，mongodb是bson格式来存储信息的菲关系型数据库，所以相对来讲，mongodb的数据更多的场景应该是聚集的数据，而不是多个表的关系联查，毕竟它是菲关系型数据库，所以mongodb更多的单个查询的场景更多一些，而mysql需要考虑索引、多表关系这些查询，这种情况下就需要b+树更合适一些。

# 普通索引和唯一索引在查询效率上有什么不同？

首先除了主键外的其他索引都是二级索引，或者叫辅助索引，这种索引也会有单独的b+树结构去存储，但是这个存储时，叶子节点存储的是主键的键值，在找到这个主键后，再去聚簇索引树内寻找对应的数据记录。

首先说唯一索引，它在查找时因为是唯一的，所以找到某条关键字记录立即停止检索，因为它是唯一的嘛。但是普通索引就不一样了，它有可能有多条记录，mysql是按页进行磁盘交互的（每页16k），当从磁盘拿到键值后，会判断还有没有数据需要拿，因此在普通索引的字段上进行查找也就是在内存中多几次判断下一条记录
的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。

# 索引是什么，什么时候失效；

## 索引如何创建

方法一：

* alter table table_name add index index_name (column_list) ;
* alter table table_name add unique (column_list) ;
* alter table table_name add primary key (column_list) ;

方法二：

* create index index_name on table_name (column_list) ;
* create unique index index_name on table_name (column_list) ;

注意create index 方法不能创建primary索引。

## 索引如何删除

* drop index index_name on table_name ; 或者：
* alter table table_name drop index index_name ;

# join on and和where条件有什么区别

首先常用的就是inner join、left join、right join。

inner join情况下没有什么区别，查出来结果是一样的

left join 使用on and条件会返回左表所有满足条件的记录，右表即使条件不满足也会以null的形式查询出来，right join是反过来的；当使用where时，则是对leftjoin/rightjoin生成的临时表进行条件过滤。

如果感觉生涩，可以直接举例，比如一张主表，和一个配置信息字典表，你拿这个主表的某个字段去连接这个字典表，如果是left join on and 字典表.xxid=xx 这时即使字典表没有记录，左表（主表）的信息也会展示出来，如果同样的条件你放在where后面执行，就会查询没有结果了，因为where是针对leftjoin出来的临时表进行筛选。

# mysql的最大连接数是多少

通常，MySQL的最大连接数默认是100, 最大可以达到16384。

# mysql的b+树是在内存中还是磁盘上的

一般每张表的b+树的根都在内存里面，因为它的结构是b+树，会依靠这种结构去查找数据，所以他是内存和磁盘结合使用的。

# union和union all区别

union对结果进行distinct，而union all连接所有结果集。

# 视图有用过吗

有用过，但是用的很少，我们是在项目内部分表重构后，用视图来过渡程序升级的，当程序升级后视图也就没用了。

# 存储过程简单讲下

存储过程是mysql或者说数据库提供的一项功能，

优点：1.从名字上就可以看出，是将sql过程化，比如某些复杂的sql，在存储过程中你可以拆开搞，实现sql过程化；2.性能好，一方面是可以减少网络带宽，另一方面存储过程一旦执行，在内存中就会保留一份这个存储过程，这样下次再执行同样的存储过程时，可以从内存中直接调用。 3.一定程度上可以防止sql注入；

缺点：1.移植性差，毕竟是在mysql内部的功能，如果数据库换了，某些使用到的特定语法就需要调整；2.调试费劲，过程中执行的sql没有好的 IDE 支持；3.耦合性高，且难维护，毕竟是放在数据库的，有可能细微的差异导致创建重复的存储过程。

# int（3）和int（6）从数值角度来讲有区别吗

int是固定4个字节，所以int（3）和int（6）从存放数字角度来说没有什么区别，int的后面这个长度不跟varchar一样是定义字符长度的，而是可以代表数字显示的宽度，所以这个长度主要是可以配合zerofill来实现不满n位0填充使用的。

# 数据库范式

1. 要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值。即保证原子性。
2. 要求实体中没一行的所有非主属性都必须完全依赖于主键；即：非主属性必须完全依赖于主键。
3. 实体中的属性不能是其他实体中的非主属性。因为这样会出现冗余。即：属性不依赖于其他非主属性。或者说每一列数据都和主键直接相关，而不能间接相关。

# sql执行顺序

FROM
<表名> # 选取表，将多个表数据通过笛卡尔积变成一个表。

ON
<筛选条件> # 对笛卡尔积的虚表进行筛选

JOIN  
指定join，用于添加数据到on之后的虚表中，例如left join会将左表的剩余数据添加到虚表中

WHERE
对上述虚表进行筛选

GROUP BY
<分组条件> # 分组

HAVING
<分组筛选> # 对分组后的结果进行聚合筛选

SELECT
<返回数据列表> # 返回的单列必须在group by子句中，聚合函数除外

DISTINCT
数据除重

ORDER BY
<排序条件> # 排序

LIMIT
<行数限制>

# sql优化

select查询优化方面

避免出现select * 只查需要的字段，无脑select*会增加磁盘io和cpu消耗；如果数据库主从是通过sql方式完成同步，则要慎用一些不确定结果集的函数比如now(),sysdate()等；where条件后面执行顺序，尽量通过从过滤大到过滤小的顺序排列，过滤更多数据之后最快速度缩小结果集；

dml语句相关

insert多条数据时尽量使用批量语句执行；

查询条件优化

对于复杂的查询，可以使用中间临时表 暂存数据；group by语句优化，默认情况下，在执行group by之后，mysql会对分组的字段进行排序，所以说在使用groupby但并不需要排序时，可以指定 ORDER BY NULL禁止排序减少cpu运算时间；union场景下，不需要过滤重复时，尽量使用union all；如果sql较复杂，可以考虑从程序的角度将它分成多个简单的sql来执行，同时避免大事务的发生；join时，尽量使用小表驱动大表，因为小表可以减少数据表的连接次数，提升效率；

防止索引失效

1、使用like模糊查询时，尽量避免使用%在前面的写法，否则索引会失效；2、not in使用时慎用，虽然not in并不是所有情况索引都失效（mysql会优化如果not in的数据量过大就会索引失效）；3、使用or查询时索引会失效，考虑是否可以通过union all；4、where条件避免进行运算或者函数的操作，当然如果没办法该用还是要用；5、使用！=或者<>，会使索引失效，如果确实业务需要，可以重新评估索引建立，避免在使用！=的字段上建立索引，没什么意义；6、复合索引时遵循最左前缀法则，比如一个复合索引a、b、c，只有在没有a的情况下索引会失效，其他情况都会走索引；7、避免隐式转换，在字段进行比较时尽量使用相同类型进行比较；8、如果使用阿里云数据库，尽量避免单表超过千万条数据，如果有这种情况，适时考虑分割表；9、选择最有效的表名顺序，from字句中写在最后的表是基础表，将被最先处理，在from子句中包含多个表的情况下，你必须选择记录条数最少的表作为基础表。尽量缩小子查询的结果

# exists和in的区别

in是先执行内表查询，再把内表结果与外表匹配，索引内表多大都要查询，不可避免，所以内表大的效率较低，外表大，内表小时更适合用in。

exists返回是true或false，它的执行呢，是以外表为单位去遍历进行比对是否有匹配项，也就是说它遍历次数取决于外表的大小，而对匹配内表可以走索引，所以外表数据小，内表大非常适合exists。

# myisam和innodb区别

1. innodb支持行锁、myisam仅支持表锁
2. innodb支持事务、myisam不支持
3. 同时innodb是聚簇索引，myisam是非聚簇索引，对于innodb的普通索引（二级索引）来说，查询一条数据可能需要回表，也就是先从索引树上找到主键，再去聚簇索引内找到数据，而myisam无论主键还是二级索引都是先从索引树上找到行地址然后定位行信息
4. MyISAM数据表允许没有主键和其他索引，而InnoDB数据表如果没有主键的话，会先找表内的唯一索引，如果没有，则默认使用表的行数来作为主键。
5. 存储文件不同，myisam和innodb都有一个文件用来存储表结构，另外，myisam会有两个文件分别用来存储数据和索引，而innodb只有一个文件来存储索引和文件。

# 分库分表

分库分表是一种思想，具体可以参考连接：https://segmentfault.com/a/1190000038944473