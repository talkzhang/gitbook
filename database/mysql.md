# 事务四大特性
事务有四大特性，分别是原子性、一致性、隔离性、持久性。简称ACID；
* 原子性（Atomicity），可以理解为一个事务内的所有操作要么都执行，要么都不执行。
* 一致性（Consistency），可以理解为数据是满足完整性约束的，也就是不会存在中间状态的数据，比如你账上有400，我账上有100，你给我打200块，此时你账上的钱应该是200，我账上的钱应该是300，不会存在我账上钱加了，你账上钱没扣的中间状态。
* 持久性（Durability），指的是一个事务完成了之后数据就被永远保存下来，之后的其他操作或故障都不会对事务的结果产生影响。
* 隔离性（Isolation），指的是多个事务并发执行的时候不会互相干扰，即一个事务内部的数据对于其他事务来说是隔离的。

这里把隔离性放到最后说，为什么呢，在数据库操作中，为了有效保证并发读取数据的正确性，提出了事务隔离级别，我平平时所说的数据库锁基本上是针对隔离级别使用的，那什么是隔离级别呢，有哪些？什么是数据库锁，又有哪些？

# 数据库隔离级别

##  读未提交

意思就是说多个事务执行期间，事务之间可以以读到别的事务未提交的数据，即脏读现象。

脏读就是读到别的事务未提交的数据，无法保证数据的准确性。因为未提交有可能会发生rollback。

## 读已提交

是说一个事务如果没有完成提交之前，别的任何查询都不会查看待提交的数据，解决了脏读，存在不可重复读、幻读现象。是oracle、sqlserver默认的隔离级别。

## 可重复读

先说下不可重复读和幻读。

**不可重复读**：意思是，比如a事务select出某个账户余额100，这期间b事务扣减了10，那这时a事务再查这个账户余额发现和之前查的不一样，这种现象叫不可重复读；

**幻读是什么**：a事务查某个条件的数据，这期间b事务insert/delete了一条满足该条件的数据，a事务会发现数量和刚开始查询的并不一致了。

不可重复读针对更新操作，幻读针对添加和删除操作，在实际开发中，幻读和不可重复读程序中是可以接受的。

既然知道什么是不可重复读，那么可重复读就是可以避免不可重复读现象的发生，比如a事务select出某个账户余额100，这期间b事务扣减了10，那这时a事务再查这个账户余额发现和之前查的是一样的，也就是说我再怎么读也和我事务开启时是一样的。

那它是如何实现的？这得从数据库锁开始说起，首先从锁的控制思想角度来讲，数据库锁分为悲观锁和乐观锁。

### 悲观锁

说明是一种态度或者情绪，给人一样，每次无论读写操作，总是认为别得操作会过来一起修改，为了防止这种情况，每次操作都加锁，无非就是读锁、写锁，锁机制是通过数据库自己实现，传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

悲观锁缺点就是资源开销较大，它适用于写多读少的场景。

### 乐观锁

乐观锁认为别的任何操作不会更改，想法很乐观，认为这次的操作不会导致冲突，但在真正更新时，会去对比判断是否真的没有冲突。

乐观锁机制非常适合读多写少场景，通常我们可以利用这种思想去完成一些操作，比如账户扣减，我们可以先把当前账户信息查询出来，之后将账户的原金额作为条件去做更新操作。

mysql、oracle这种比较成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免可重复读和幻读问题，当然每个数据库实现的方式也有差别，我们是用的是mysql innodb引擎，所以只说myql是如何在可重复读隔离级别下解决可重复读、幻读问题。

### MVCC在innodb中的应用

在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值分别是当前行创建版本和删除版本号，它的实现逻辑规则：

* SELECT时，当前事务版本号>=读取创建版本号，当前事务版本号<删除版本号或除版本号为空。
* INSERT时，保存当前事务版本号为行的创建版本号
* DELETE时，保存当前事务版本号为行的删除版本号
* UPDATE时，首先update是先把当前更新的数据删除，然后插入一条新纪录，所以保存当前事务版本号为行的创建版本号，删除的原行呢，也会将当前事务版本号给记录下来。

通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。

### 说回来这个隔离级别

数据库的可重复读隔离级别下，可以利用MVCC机制生成一个查询快照，只要你开启了事务，那么会优先查看快照，不存在则去当前读。

快照读和当前读的区别就是，快照是读的某一个时刻的版本，当前读读的是实时的。

快照读就是普通的select....

当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。例如：

* select * from table where ? lock in share mode;
* select * from table where ? for update;
* insert;
* update ;
* delete;

读操作：

有这种机制在，举例某张表就一条数据 A事务查询select * 就能查到一条数据，且是当前事务版本号，b事务在a事务没完成期间插入了一条数据，并成功commit，那么A事务还是只查到一条数据。

写操作：

说写操作之前应该先说一下next-key锁，可重复提交利用这种机制可以避免幻读，什么是next-key锁呢？就是行锁+gap（间隙锁），那么什么是gap锁？首先mysql的数据结构是b+树，所有的键都在叶子节点上，那么这个叶子节点并且是有序的，间隙锁锁定的是节点与节点之间的位置，正如其名嘛。

同时会把<5的这个数据的索引的区间也给锁住，防止其他数据插入进来。这就是间隙锁锁定的位置区间。

我们说回写操作，比如某个字段是索引，它的值有1、3、5，事务A想要更新数据，更新条件是<5，在A事务提交之前，1、3两行数据会上行锁，这个没什么好说的，这时B事务想要插入一条2的数据，由于可重复读隔离级别下，mysql使用了next-key锁，这时2并作为间隙有锁，所以事务B会阻塞提交，就是等待A事务commit之后，B事务的插入动作才会执行，如果阻塞时间超时就会报lock wait timeout这种异常错误。

综上所述，mysql的可重复读隔离级别，在本地验证下呢，避免脏读的同时，也避免了不可重复读、幻读。不可重复读通过快照读避免，幻读通过next-key锁来实现。

你可能要说了，可重复读这不是挺牛的吗，为什么不使用可重复读呢？首先从实现角度来说确实做了很多优化，但是像幻读、不可重复读这种情况我们是完全可以接受的， 虽然可重复读隔离做了很多优化，但是和读已提交相比，快照读、间隙锁还是会增加系统开销，所以生产环境一般使用读已提交隔离级别。

## 序列化Serializable

这个级别很简单，读加共享锁，写加排他锁，读写互斥。使用的悲观锁的理论，实现简单，数据更加安全，但是并发能力非常差。

# 数据库有哪些锁

从实现角度来说有悲观锁和乐观锁，上面又提到。

从落地方面来说有共享锁、排他锁、间隙锁。表锁。

**共享锁**

select ... lock in share mode.

共享锁是读锁，允许其他事务进行读操作，但不允许其他事务进行写操作。

**排他锁**

这就是所谓的写锁，不允许其他事务对已经获取写锁的数据进行读锁或者写锁。

**间隙锁**

上面有提到，可翻上复习。

**表锁**

就是把整张表都上锁，其他任何想要操作表的事务都获取不到锁。

**行锁**

行锁是一种上锁的称呼，行锁可以是排他锁，也可以是共享锁。

# mysql 为什么使用b+树

从数据库交互说起，数据库交互无非就是io操作，计算机存储设备一般分为两种：内存储器和外存储器，内存虽然很快但是没有持久性，所以数据库的数据都是存储在磁盘上的，而磁盘的读写速度取决于寻道时间、旋转延迟、传输时间三方面。寻道时间基本上市面上的磁盘一般在5ms以下，旋转延迟就是计算机磁盘转速，比如一个磁盘7200转，也就说说它一分钟能赚7200次，旋转延迟就是1/120/2 = 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。基于这个例子，那访问一次数据库的时间就是大概9ms左右，数据库动辄上百万上千万数据，一次磁盘io需要9ms，所以io次数多会严重影响数据库读写效率，所以需要一套能够减少磁盘io交互的数据结构。

先说为什么不使用红黑树、或者平衡二叉树。主要原因是因为红黑树和平衡二叉树存储的节点高度会过高，毕竟二叉树每个节点只能有一个元素，且子节点只能有两个，对数据库数据来讲，成千上万的数据高度过高，每一层高度就要和磁盘打一次交道，这样会大大降低数据库效率，所以需要一种能在尽量少io操作的情况下就可以完成的一套数据结构。

再说b+树之前，先说下什么是b树，b的结构相对二叉树来讲，它最大特点就是每个节点可以存储多个元素，并且通过定义阶这个概念，可以拥有两个以上的子节点，当然b树有它详细的添加元素和删除元素的规则，这里不用赘述，使用b树可以大大降低树的高度，因为它可以多个元素，多个节点嘛。所以还是非常适合数据库这种与磁盘打交道的场景的，b树存储结构如图所示：

![b树存储结构](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20220309164414.png)

b树可以用于菲关系型数据库，比如mongodb。

说回来b+树，b+树是针对b树做了一些调整，使它更适合于关系型数据库，具体调整有

1.非叶子节点中每个元素不保存数据，只用来索引，所有数据都保存在叶子节点；这样在索引数据时，比如mysql每次查询数据按页查询，它的默认值是16kb，每次容量上限相同的查询情况下，b+树一次io会比b树查询出更多的键值。

2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接，所以非常适合范围查找，而b树要完成范围查找，则需要跨树层中序遍历，增加了io，效率相对较低。

其次，b+树所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素，b树是各管各的，不存在这种规则；

b+树存储结构图：

![b+树存储结构](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20220310114239.png)

参考连接：https://www.cnblogs.com/lianzhilei/p/11250589.html

# mysql查询过程是什么样的

# mysql多个索引是如何存储的

# 为什么不建议字段过长

# MongoDB为什么使用B树不用b+树

从根本上来讲，mongodb是bson格式来存储信息的菲关系型数据库，所以相对来讲，mongodb的数据更多的场景应该是聚集的数据，而不是多个表的关系联查，毕竟它是菲关系型数据库，所以mongodb更多的单个查询的场景更多一些，而mysql需要考虑索引、多表关系这些查询，这种情况下就需要b+树更合适一些。

# 普通索引和唯一索引在查询效率上有什么不同？

首先除了主键外的其他索引都是二级索引，或者叫辅助索引，这种索引也会有单独的b+树结构去存储，但是这个存储时，叶子节点存储的是主键的键值，在找到这个主键后，再去聚簇索引树内寻找对应的数据记录。

首先说唯一索引，它在查找时因为是唯一的，所以找到某条关键字记录立即停止检索，因为它是唯一的嘛。但是普通索引就不一样了，它有可能有多条记录，mysql是按页进行磁盘交互的（每页16k），当从磁盘拿到键值后，会判断还有没有数据需要拿，因此在普通索引的字段上进行查找也就是在内存中多几次判断下一条记录
的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。

# 索引是什么，什么时候失效；

## 索引如何创建

方法一：

* alter table table_name add index index_name (column_list) ;
* alter table table_name add unique (column_list) ;
* alter table table_name add primary key (column_list) ;

方法二：

* create index index_name on table_name (column_list) ;
* create unique index index_name on table_name (column_list) ;

注意create index 方法不能创建primary索引。

## 索引如何删除

* drop index index_name on table_name ; 或者：
* alter table table_name drop index index_name ;

# join on and和where条件有什么区别

首先常用的就是inner join、left join、right join。

inner join情况下没有什么区别，查出来结果是一样的

left join 使用on and条件会返回左表所有满足条件的记录，右表即使条件不满足也会以null的形式查询出来，right join是反过来的；当使用where时，则是对leftjoin/rightjoin生成的临时表进行条件过滤。

# mysql的最大连接数是多少

通常，MySQL的最大连接数默认是100, 最大可以达到16384。

# mysql的b+树是在内存中还是磁盘上的

一般每张表的b+树的根都在内存里面，因为它的结构是b+树，会依靠这种结构去查找数据，所以他是内存和磁盘结合使用的。