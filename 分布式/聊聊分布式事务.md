# 从数据库事务说起

事务有四大特性，分别是原子性、一致性、隔离性、持久性。简称ACID；

* 原子性（Atomicity），可以理解为一个事务内的所有操作要么都执行，要么都不执行。
* 一致性（Consistency），可以理解为数据是满足完整性约束的，也就是不会存在中间状态的数据，比如你账上有400，我账上有100，你给我打200块，此时你账上的钱应该是200，我账上的钱应该是300，不会存在我账上钱加了，你账上钱没扣的中间状态。
* 隔离性（Isolation），指的是多个事务并发执行的时候不会互相干扰，即一个事务内部的数据对于其他事务来说是隔离的。
* 持久性（Durability），指的是一个事务完成了之后数据就被永远保存下来，之后的其他操作或故障都不会对事务的结果产生影响。

# 分布式事务项目中是怎么处理的

使用微服务架构可以解决开发、部署遇到的一些一些问题，但是随之而来也会带来一些问题，分布式事务就是典型的场景。

首先分布式事务这种场景如果业务侧能够规避做到尽量规避，如果确实到了分布式事务场景在考虑选择处理方案，即业务规避>分布式事务解决。

项目中用到分布式事务场景不算多，一般都通过业务规避，这里说一个项目中用到的地就ok，然后说一下落地的几种方案。

对分布式事务还是有过一些了解，根据不同的场景，可以选择不同的解决方案落地，在说几种解决方案之前应该说下众所周知的cap理论和base理论，cap大概是说分布式系统的一致性、可用性、和分区容错性三者不能兼备，那base理论大概是说保证系统基本可用，且最大程度满足一致性，即最终一致性。

无论哪种理论，其实在我们实现时都有一个宗旨，比如cap，我们优先使用cp（强一致性的组合，刚性事务），那我们并不是说a就不要了，而是最大程度保证a（可用性），反之，如果我们使用ap（柔性事务），我们也要最大程度保证c（即最终一致性），这才是系统落地时无论使用那种方案要考虑的。

## 两阶段提交（CP）

在说两阶段提交之前先说一下xa协议，XA是一个规范、协议，它只是定义了一系列的接口，只是目前大多数实现XA的都是数据库或者MQ，所以提起XA往往多指基于资源层的底层分布式事务解决方案。而XA模型主要使用了两段提交来保证事务的完整性。xa内有是哪个角色，分别是参与者、资源管理者、和事务协调者。

这里的参与者可以理解为分布式应用程序，协调者可以理解为一种中心化全局的应用程序，资源管理者可以理解为我们的数据库，数据支持xa，那么就有一些列可执行的语法来完成。

第一个阶段先预提交，但没有真正提交，但这时资源是锁定的，第二阶段根据第一阶段执行情况执行commit/rollback，这里提一下在真正执行时，都是通过xa命令绑定的当前事务id来进行操作的。比如命令有xa start txid，xa end txid，xa prepare txid，xa commit txid，xarollback txid。

![2阶段提交正常流程](https://cdn.jsdelivr.net/gh/talkzhang/imgs-bed@master/image/20220217142851.png)

2阶段提交实现了事务提交的强一致性，但是存在很大的缺陷：

1. 阻塞，在第一阶段锁定资源，有可能存在网络故障或者节点宕机，这期间资源一直锁定。可以通过超时机制避免阻塞时间无法控制的现象。
2. 数据一致性风险，在第二阶段，协调者通知参与者，通知A后宕机，A执行了commit，宕机后通过选举出新的协调者不知道b是否执行了commit，会造成某段时间内数据不一致。当然可以通过xa日志记录来解决这种现象。
3. 协调者在发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了，那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交，该问题无法解决。

## 三阶段提交

针对两阶段暴露出来的问题，通过三阶段提交可以用来解决其中的缺点。

3PC，三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点：

（1）在协调者和参与者中都引入超时机制

（2）在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。

所以3PC会分为3个阶段，CanCommit 准备阶段、PreCommit 预提交阶段、DoCommit 提交阶段，处理流程如下：

![](https://cdn.jsdelivr.net/gh/talkzhang/imgs-bed@master/image/20220217144530.png)

三阶段提交会在precommit阶段记录undo和redo日志，用于解决由于网络、宕机等原因造成的数据不一致问题的恢复。

三阶段通过超时机制降低了资源阻塞时间；同时因为是三阶段，在执行最终docommit阶段时，有理由相信是要commit的，所以如果在dommit阶段协调者宕机，参与者在超时之后会自动提交commit。

三阶段提交的数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 doCommit 指令时，此时如果协调者请求中断事务，而协调者因为网络问题无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。

2pc和3pc应用场景：适用于单体应用，同时操作不同的数据库时使用，常见的实现框架：jta

## TCC

上面的2、3阶段提交都是基于数据库层面的，而Tcc是基于应用层的两阶段提交。所以对代码的侵入性强。

其核心思想是：针对每个操作，都要实现对应的确认和补偿操作，也就是业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作，第一阶段由业务代码编排来调用Try接口进行资源预留，当所有参与者的 Try 接口都成功了，事务协调者提交事务，并调用参与者的 confirm 接口真正提交业务操作，否则调用每个参与者的 cancel 接口回滚事务，并且由于 confirm 或者 cancel 有可能会重试，因此对应的部分需要支持幂等。

tcc默认认为在confirm阶段是不会出现任何异常的，也就是说只要 Try 成功，Confirm 一定成功（TCC设计之初的定义），Confirm 与 Cancel 如果失败，由TCC框架进行重试补偿，存在极低概率在CC环节彻底失败，则需要定时任务或人工介入。

tcc在使用时要注意：

1. 空回滚出现的原因是 Try 超时或者丢包，导致 TCC 分布式事务二阶段的 回滚，触发 Cancel 操作，此时事务参与者未收到Try，但是却收到了Cancel 请求,也就是 Cancel 执行时如果发现没有对应的事务 xid 或主键时，需要返回回滚成功，让事务服务管理器认为已回滚。
2. 悬挂指的是二阶段的 Cancel 比 一阶段的Try 操作先执行，出现该问题的原因是 Try 由于网络拥堵而超时，导致事务管理器生成回滚，触发 Cancel 接口，但之后拥堵在网络的 Try 操作又被资源管理器收到了，但是 Cancel 比 Try 先到。但按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，所以此时应该拒绝执行空回滚之后到来的 Try 操作，否则会产生数据不一致。
3. 幂等控制：由于网络原因或者重试操作都有可能导致 Try - Confirm - Cancel 3个操作的重复执行，所以使用 TCC 时需要注意这三个操作的幂等控制，通常我们可以使用事务 xid 或业务主键判重来控制。
4. 业务模型分2阶段设计，这个就是try阶段做的事情，比如你要扣减某个账户1元，在try阶段可以先把这1元冻结起来，在comfirm时再完成扣减，在cancel时将这个冻结的金额补到余额上。

tcc优点：相比较xa协议，减少了资源阻塞时间，性能较好。同时因为它是在应用层的实现，所以可靠性相对更好一些。

tcc缺点：很明显，业务耦合较严重，需要代码完成提交和回滚的数据复杂逻辑，增加开发成本。

实现tcc的框架：Hmily

## Saga事务

saga它的实现是事务分段依次提交的思想，就是多个事务执行的过程中，每个事务依次提交之后再执行下一个事务，如果过程中出现异常，可则由 Saga 事务协调器协调根据相反顺序调用补偿操作，回滚已提交的参与者，使分布式事务回到最初始的状态。

这个补偿操作是通过业务代码编写的。

saga的恢复策略有两种：

1. 向前恢复，在执行过程中中间某个事务失败，需要回滚，则向前按顺序将已执行的事务数据进行补偿操作，即回到之前的状态。
2. 向后恢复，在执行过程中中间某个事务失败，不需要回滚，会重试继续执行，该模式认为事务执行必须成功，可设置重试次数，超限后通知人工处理。

适用场景：业务流程长，业务流程多的长事务。

优点：一阶段提交，无锁，高性能。

缺点：不能保证隔离性。

## 事务消息

通过mq中间件配合完成，为什么单独冒出来个事务消息？提交完事务发送消息到mq等待它的消费者消费不就行了吗，有什么好说的。

那就说手为什么要使用事务消息，首先举例，当用户支付成功，将会更新支付订单，然后发送 MQ 消息。手续费系统将会通过拉取消息，计算手续费然后保存到另外一个手续费数据库中。如下图：

![业务场景举例](https://cdn.jsdelivr.net/gh/talkzhang/imgs-bed@master/image/20220217182620.png)

流程主要涉及三个步骤：

* 更新订单数据
* 发送消息给 MQ
* 手续费系统拉取消息
* 

上面提到的步骤，任何一个都会失败，如果我们没有处理，就会使两边数据不一致，将会造成下面两种情况：

* 订单数据更新了，手续费数据没有生成
* 手续费数据生成，订单数据却没有更新

怎么会呢，我感觉没问题啊，正常发就好了，怎么可能不一致，不着急，举例说明：

1 先发送消息，后提交事务，消息发送成功了，事务失败了，导致手续费和订单数据不一致

2 先将更新订单的事务写完并提交，而后发送消息，试想下如果事务提交成功，消息发送失败，就会导致数据不一致。

3 将更新订单和发送消息写在一个事务内，发送失败就回滚了，ok，看起来没问题吧，那如果消息明明发送了，但是由于网络原因一直没有收到回执，导致抛出异常认为失败，而回滚了订单数据，而事实上消息已经发出去了，所以数据照样不一致，你会说mq有重试机制可以设置次数啊，但是这和提交更新订单的是在一个事务内啊，重试的机制会导致资源的长时间阻塞，影响了整个订单系统，所以还是不妥吧。

针对以上问题，无非就是一个，那就是难以完美的保证消息发送和事务执行的原子性，事务消息就是用来解决这个问题的。

以 RocketMQ 为例，它提供了事务功能，可以实现分布式事务，从而保证上面事务操作与消息发送要么都成功，要么都失败。

![事务消息执行流程](https://cdn.jsdelivr.net/gh/talkzhang/imgs-bed@master/image/20220217184223.png)

这个 `半消息`与普通的消息唯一的区别在于，在事物提交之前，这个消息对消费者来说是 `不可见`的，消费者不会消费这个消息。

那么流程就是发送半消息->执行本地业务流程提交/回滚->提交成功则发送成功消息到mq，手续费会正常消费，失败则发送回滚通知到mq，mq会删掉这条半消息。

那么如果我们提交/回滚事务消息失败怎么办？对于这个问题，RocketMQ 给出一种事务反查的机制。我们需要需要注册一个回调接口，用于反查本地事务状态。RocketMQ 若未收到提交或回滚的请求，将会定期去反查回调接口，然后可以根据反查结果决定回滚还是提交事务，当然这里反查机制内可以设置每隔多久、以及最大查询次数都可以动态配置。

## 本地消息表

可以看到mq事务处理是依赖mq中间件来存储消息，而本地消息表是通过使用数据库建一张消息表，根据表的状态来完成的。

和消息事务思想差不多，消息事务是保证将本地事务和放入消息的动作的原子性，而本地消息表则是在本地事务执行时插入本地消息表，这张表插入之后在发送消息队列异步通知下一个需要处理的事务，在这中间如果发生消息发送不成功，或者消费服务没有消费怎么办？这时可以创建一个定时任务定期扫描消息表，将消息表内状态没发送的重新发送供消费者消费即可，这里有可能发生消费者多次消费同一个事务的问题，所以消费者端在开发时要保持业务执行的幂等性。

![本地消息表解决场景示例图](https://cdn.jsdelivr.net/gh/talkzhang/imgs-bed@master/image/20220218184853.png)

## SEATA的AT模式

阿里巴巴研发的SEATA中的AT模式，也是两阶段提交思想的一种实现，它是通过记录undolog日志表来记录事务提交前(beforeImage)和提交后(afterImage)的数据状态，在第一阶段就和undolog一起提交，第二阶段提交/回滚，提交的话就把undolog记录删掉，回滚的话就恢复undolog内记录的数据之前的状态，当然会进行脏数据校验，不通过则可以通过人工介入处理。

比如说分布式架构中，a通过rpc调用b，在第一阶段a会先提交本地事务连带记录的undolog记录表一起，提交完之后执行b，b执行提交，这是第一阶段做的事情。比如b提交失败需要回滚，那么a就会根据undolog日志内记录来完成数据的回滚，

个人认为at模式准确来说应该叫分阶段提交，这种提交模式和本地消息表、mq事务类似，都是分阶段提交，如果需要都可以加入undolog日志来完成。
