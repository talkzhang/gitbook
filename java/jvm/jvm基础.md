> 抱着一脸懵逼的表情，我拿起了《深入java虚拟机》看了起来，从开篇到现在，个人感觉书上内容还算容易理解，但是部分细节可能会理解有偏差，为防止以后踩坑，现将所认为重点笔记记录于此。
> 
# jvm内存模型

根据《java虚拟机规范》来换分jvm的区域的话主要有：

> **程序计数器、本地方法栈、虚拟机栈、方法区、堆。**


如图：

![jvm内存模型](https://gitee.com/hongqigg/imgs-bed/raw/master/image/341ef05061e750a9c16bed913bd32b2c.jpg)

从运行时分类，大致可以分为线程公有、线程私有两种类型。

1. 线程私有包括：程序计数器、虚拟机栈、本地方法栈。 
 
2. 线程公有包括：堆、方法区。


## 线程私有
### 程序计数器

1、是一块比较小的内存区域  
2、用来记录当前线程执行到的字节码行号  
3、由于只是用来记录行号，所以不存在内存溢出情况，是 JVM 内存区域中唯一一个没有定义 OutOfMemoryError 的区域  
4、每个线程都需要一个程序计数器用来记录执行哪行字节码，所以程序计数器是线程私有的  

### 虚拟机栈

1、每个方法调用时，线程都要为该方法创建一个栈帧，主要用来保存该函数的返回值、局部变量表（用于存放方法参数和方法内部定义的局部变量）动态连接、操作数栈（保存数据类型）等

2、当方法被调用时，栈帧在虚拟机栈中入栈，当方法执行完成时，栈帧出栈

3、一个线程中的方法调用可能会很长，很多方法处于执行状态。在线程中，只有虚拟机栈顶的栈帧才是有效的，称为当前栈帧，该栈帧所关联的方法称为当前方法

4、虚拟机栈中，定义了两种异常：StackoverflowError：当线程调用的栈深度大于虚拟机允许的最大深度OutOfMemoryError：线程一只申请栈，直到内存不足（多数 Java 虚拟机允许动态扩展虚拟机栈的大小）

5、每个线程都对应一个虚拟机栈，因此虚拟机栈也是线程私有的

6、局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。

### 本地方法栈

和虚拟机栈的作用一样，只不过虚拟机栈执行的java方法，而本地方法栈执行的native方法，它也会抛出stackoverflowerror和outofmemoryerror。

## 线程共享
### java堆

1、用于存储对象实例，几乎所有的对象实例以及数组都在这里存储。2、Java堆是`垃圾收集器管理`的内存区域。3、如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。可以通过参数-Xmx和-Xms设定

### 方法区

1、在 Java 虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆

2、在 HotSpot（JDK 默认虚拟机实现） 中，将方法区当做永久代

3、方法区是各个线程共享的区域，用于存储全局变量、静态变量、常量、加载的类信息（包括版本、方法、接口等）等方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。

4、方法区在物理上也不要求是连续的，可以选择固定大小或可扩展大小

5、可以设置方法区是否进行垃圾回收

6、当内存不足时，方法区会抛出 OutOfMemoryError: PermGen space 异常

7、java8采用了元空间来替代永久代，因为永久代的存在有一个难以容忍的缺点：.永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，这样就会造成开发人员拿捏不准设置，或者忽略了该设置而导致oom。jdk6之后也就是jdk7，实现了将原本放在永久代的字符串常量池、静态变量等移出，而到了JDK 8，终于完全废弃了永久代的概念。

8、相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。比如说类似spring框架应用字节码技术来动态生成代理类的这种框架，就需要虚拟机具备这种能力了。根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OutOfMemoryError异常。

#### 运行时常量池
这块区域，属于方法区，用来存放什么呢？用来存放编译期生成的各种字面量与符号引用，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是**String类的intern()方法**。

- String.intern()方法作用是什么？

这个方法是干什么用的呢，简单介绍一下：如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。

详情示例可查看美团技术团队博文，地址：[https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html](https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)

从string.intern方法可以看出jdk7之后将字符串常量池从防区挪到了堆内存中，所以同样的代码可能在jdk6和jdk7甚至之后的版本中有所差异，具体不做赘述。

## 直接内存 

**java从1.4引入NIO之后，可以通过native函数直接分配堆外内存，这样在一些场景中可以提高性能，因为避免了Java堆和native堆来回复制数据**，为什么呢？ 

使用堆外内存的话，堆外内存是直接受操作系统管理( 而不是虚拟机 )。这样做的结果就是能保持一个较小的堆内内存，以减少垃圾收集对应用的影响。 堆内内存由JVM管理，属于“用户态”；而堆外内存由OS管理，属于“内核态”。如果从堆内向磁盘写数据时，数据会被先复制到堆外内存，即内核缓冲区，然后再由OS写入磁盘，使用堆外内存避免了这个操作。  

JVM虚拟机是运行在操作系统上的进程，操作系统分配给JVM的内存在启动是有限的，不可能把全部内存都分配给JVM，Java NIO又用到了直接内存技术，利用Channel和Buffer直接操作JVM外的内存，避免数据在JVM和操作系统内存之间来回复制。但是，当JVM和直接内存的和大于操作系统总内存时，就会发生内存溢出（oom）。

# 虚拟机对象
## 一、对象创建
一个**普通对象**的创建，在java虚拟机中是如何创建的，

1. 遇见new关键字
2. 能否在常量池中定位到类符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。
3. 如果没有，那必须先执行相应的类加载过程。

## 二、内存分配

1. 假设内存是规整的，通过指针分界用过的内存和空闲内存，这种分配方式叫做“指针碰撞”（Bump the pointer）

2. 假设内存是不规整，通过维护一个列表来记性内存的分配，这种分配方式叫做“空闲列表”


选择哪种分配方式由java堆来决定，堆又是根据垃圾收集器是否具备压缩整理能力决定的，具备这种能力的就采用简单高效的指针碰撞，否则就只能使用空闲列表。  

对象创建的线程安全性问题，这个问题如何解决？

1. 通过同步处理来进行解决，具体虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性，但是多线程下频繁的运算会影响系统运行效率。

2. 给每块线程预先分配一小块内存，即本地线程分配缓冲，这种方式还有个名称TLAB（Thread Local AllocationBuffer），本地缓冲区用完的时候才通过第一步的同步处理来进行解决，是否使用TLAB可以通过-XX：+/-UseTLAB参数来设定，而tlab的每个线程的大小是根据采样算法得出的。

## 三、对象布局
对象布局分为三个部分：对象头、实例数据、对齐填充。
- 对象头：两种类型的数据，一种是存储GC年龄、hash码、持有锁的信息等等，另一种类型就是类型指针，通过这个指针可以确定是哪个类的实例。

- 实例数据：就是真正我们开发中使用的数据。

- 对齐填充：从名字就可以看出来，是为了补缺/补漏用的，这是因为hotspot虚拟机要求对象的起始地址必须是8字节的整数倍，对象头信息已经被精心设计为整数倍，但是实例数据存在不确定性，所以拿它来对齐，至于为什么这么设计，那肯定是为了提高空间利用率。


## 四、对象访问
对象访问分为句柄和直接访问，句柄无非就是在对象实例上面又抽象出的一层管理的空间，在句柄中指向了实际对象的地址，直接指向对象地址，没什么好说的把，就是直接访问指向。


需要注意的是，如果在栈中的指针指向了句柄，那么当对象的地址发生el变化，只需要在句柄中维护正确就好了，而不会影响到栈内的reference，反之，如果在栈内直接饮用了对象，那么对象位置发生变化需要将栈内的reference维护正确。

![](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20210702152322.png)

# 垃圾收集算法
> 再说垃圾收集算法之前，应该先了解如何判定对象是垃圾呢？

## 如何判定对象该回收（是垃圾）

### 引用计数法

即通过给对象天剑一个计数器，对象有被引用时数值就+1，引用失效时呢，数值-1，只要计数器的数值=0时说明这个对象肯定不能用了，该被回收了。
引用计数法肯定是简单高效，但是这个算法最坑的一方面就是比如出现循环引用时的计数失效问题，要解决这个问题需要做很多处理，在java hotspot内是没有使用这个算法的。

### 可达性分析算法

这个算法大致就是通过一系列的“GC Roots”来作为根节点，根节点的作用是什么呢？就是通过它来查看对象是否存在有效引用连，如果没有，则认为对象差不多该认为是垃圾去回收了。

GC Roots对象包括如下：

- 虚拟机栈中引用的对象。
- 类静态属性引用的对象。
- 常量引用的对象
- JNI引用的对象
- 虚拟机内部饮用，比如一些常用的异常（Nullpointerexception这种）、基本类型对应的class对象、以及系统类加载器等。
- 所有被同步锁持有的对象
- 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。


### 驸：“引用”的概念

JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。 强引用：不回收； 软引用：描述还有用但非必须的对象。回收时内存紧张回收； 弱引用：在下次垃圾回收之前，无论内存是否紧张都会回收； 虚引用：不会对对象的生存时间造成任何影响，使用它的唯一目的只是为了能在这个对象进行垃圾回收时收到系统通知。 


## 对象回收步骤

1、在进行可达性分析算法之后筛选出来这些对象； 

2、判断此对象是否必要执行finalize()方法！如果对象没有覆盖finalize()方法或者finalize()已经被JVM调用过，则这个对象就会认为是垃圾，可以回收。 

3、如果出现覆盖finalize方法且没被调用过的这些对象，会被虚拟机放入F-QUEUE中，稍后由一个优先级为低调度的线程去执行，执行完之后（就是执行finalize方法），虚拟机对这个队列中进行二次标记，如果发现执行完finalize后又产生对象引用链，则将该对象移出“对象回收”集合，否则当作垃圾回收！ 


## 方法区回收

jdk1.8之后虽然方法区从永久代挪到了元空间，但是这部分内存对虚拟机来说，还是归它管理。 

方法区回收什么东西呢？ 

1. 废弃的常量。 
2. 不再使用的类型  
  2.1 该类所有的对象已被回收；  
  2.2 加载该类的类加载器已被回收；  
  2.3 该类的class对象没有在任何地方引用，即通过反射已无法获取该对象 因为现在有大量使用反射、动态代理等字节码框架（例如spring）会增加方法区的内存压力，所以这种情况下需要虚拟机支持类卸载的能力！ 

## 垃圾收集算法

基于分代理论，有“Minor GC”、“Major GC”、“Full GC”这样的回收类型。
- minor gc 回收新生代
- major gc 回收老年代
- full gc 回收新生代+老年代

垃圾回收算法主要包括标记-清除、标记复制、标记整理算法。

所有的算法都跳不过`标记`这一过程，所以可以说，垃圾回收算法基本上都是基于标记来进行算法操作的。

### 标记-清除

分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。

标记过程就是对象是否属于垃圾的判定过程，这在上面[如何判定对象该回收/是垃圾](#如何判定对象该回收是垃圾)讲述垃圾对象标记判定算法时其实已经介绍过了。

标记清除是最基础的垃圾收集算法，别的算法都是基于这种思想来进行拓展设计界的，它的主要缺点：

1. 执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低
2. 内存空间碎片化，清除之后产生了大量的不连续的内存碎片，标记、清除之后会产生大
量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找
到足够的连续内存而不得不提前触发另一次垃圾收集动作。

![标记-清除算法示图](https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16091547922390.png)

### 标记-复制

为了解决标记清除法的效率问题，也就是在需要回收大量对象的时候的效率低下的问题，出现了标记复制算法，也可以叫做复制法。

它的主要工作原理是将可用内存分为大小相等的两块，每次都使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

如果内存中大多数对象都不需要回收，那这种算法就会产生较多的内存复制的开销，相反，如果需要复制的是少数的对象，效率还是很高的，这说明标记复制算法适用于对象频繁需要回收的场景。

而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效。

`缺点`也显而易见，就是将可用内存缩小到了原来的一般，资源浪费的有点过多。

![标记-复制图示](https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16115581754210.png)

hotspot虚拟机内将新生代分为Eden和Survivor区，其中survivor区有两个（实现了标记复制），它们的占比是8：1，也就是说在新生代有10%的空间会被浪费，毕竟新生代的对象回收率达到98%，但是这个数值并不是绝对，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，所以这里有`逃生门`的安全设计，当survivor区域无法容纳minor gc之后剩余的存活的对象时，就会依赖其他区域来进行分配担保，这个其他区域一般也就是老年代。

### 标记-整理

标记复制固然高效，但是它的空间浪费比较严重，且不太适用于存货大量对象的场景，会降低执行效率，且复制过程中，还要有分配担保机制保证它执行的安全性。

标记整理的原理：它的标记过程和标记-清除是一样的，只是标记-清除是对标记的对象进行内存清理，而标记-整理的操作是让所有存货的对象都向内存空间的一端移动。，然后直接清理边界以外的内存，`标记-清理`算法和`标记-整理`的区别是前者是非移动式的算法，而后者是移动式算法。

![标记-整理图示](https://gitee.com/hongqigg/imgs-bed/raw/master/image/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_16115608044721.png)

标记整理固然不错，但是它的缺点也很明显，在移动对象并更新引用这些对象的地方是一种极为负重的操作，这种操作需要停止别的所有线程的工作，也就是所谓的`stop the world`。

但是如果像标记-整理那样不对存活的对象进行移动操作的话，弥散于堆中的空间碎片化问题就需要得到解决，只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过“分区空闲分配链表”来解决内存分配问题。这样的话说明业界内的确也有对标记清除算法的解决方式，但是如果不移动对象，势必要在内存分配时做更多复杂话操作，势必会直接影响应用程序的吞吐量。

所以这就取决于垃圾收集器更关注哪方面了，如果更关注吞吐量的话，那就在标记后进行对象的移动，但是这样可能会存在延迟问题（例如：Parallel Scavenge）；如果关注延迟问题，那就在分配对象时解决问题，但是这样会降低系统吞吐量（例如：CMS，ps：cms一般情况下使用标记清除，但是如果内存碎片影响到对象分配，则使用标记-整理收集一次）。

### java堆跨代引用如何回收处理

一张图说明一下

![java堆跨代引用回收处理](https://gitee.com/hongqigg/imgs-bed/raw/master/image/jvm%E5%A0%86%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E5%A4%84%E7%90%861.png)

例如新生代的`对象3`被老年代的某个对象引用时，为了方便GC roots扫描，新生代会有一钟数据结构`Remembered set`来进行跨代应用的记录，这样的减少了扫描整个老年代的代价，图中的A、B、C等区域是remembered set的逻辑分区，新生代进行垃圾回收时，存在跨代引用的对象，会查看`Remembered set`中记录的区域，然后扫描这个区域中是否还有引用链的存在，以满足可达性分析算法的Gc Roots条件来进行垃圾回收。

各垃圾收集器

![](https://gitee.com/hongqigg/imgs-bed/raw/master/image/f9146fe9dea7c21cec0992e8b0f9a2a9.jpg)

这个关系不是一成不变的，由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP 173），并在JDK 9中完全取消了这些组合的支持（JEP 214）。

没有最好的垃圾收集器，只有特定场景特定堆区下最适宜的，分类如下：
- 新生代收集器：Serial、ParNew、Parallel Scavenge；
- 老年代收集器：Serial Old、Parallel Old、CMS；
- 整堆收集器：G1；

## Serial

最老的垃圾收集器，典型的stop the world.

![Serial/Serial Old收集器运行示意图](https://gitee.com/hongqigg/imgs-bed/raw/master/image/a165d3d0487ba80e7b946455e2c385fd.jpg)

单线程进行垃圾回收。迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。

JVM Server模式与client模式启动的差别？

最主要的差别在于：-Server模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升.原因是:
当虚拟机运行在-client模式的时候,使用的是一个代号为C1的轻量级编译器, 而-server模式启动的虚拟机采用相对重量级,代号为C2的编译器. C2比C1编译器编译的相对彻底,,服务起来之后,性能更高.
所以通常用于做服务器的时候我们用服务端模式，如果你的电脑只是运行一下java程序，就客户端模式就可以了。当然这些都是我们做程序优化程序才需要这些东西的，普通人并不关注这些专业的东西了。其实服务器模式即使编译更彻底，然后垃圾回收优化更好，这当然吃的内存要多点相对于客户端模式。


# 题外
## 如何查看jdk默认垃圾收集器
目前工作单位系统使用的垃圾收集器是1.8，命令**_java -XX:+PrintCommandLineFlags -version_**可以查看当前系统垃圾收集器使用情况。以我当前电脑环境配置为例：
```powershell
C:\Users\coolshell>java -XX:+PrintCommandLineFlags -version
-XX:InitialHeapSize=132172352 -XX:MaxHeapSize=2114757632 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
java version "1.8.0_261"
Java(TM) SE Runtime Environment (build 1.8.0_261-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)
```
可以看到**UseParallelGC**，使用了parallelGC， 即 **Parallel Scavenge + Parallel Old**，再查看详细信息，使用**_java -XX:+PrintGCDetails -version_**可以查看详细信息：
```powershell
C:\Users\coolshell>java -XX:+PrintGCDetails -version
java version "1.8.0_261"
Java(TM) SE Runtime Environment (build 1.8.0_261-b12)
Java HotSpot(TM) 64-Bit Server VM (build 25.261-b12, mixed mode)
Heap
 PSYoungGen      total 38400K, used 2670K [0x00000000d5f80000, 0x00000000d8a00000, 0x0000000100000000)
  eden space 33280K, 8% used [0x00000000d5f80000,0x00000000d621bb30,0x00000000d8000000)
  from space 5120K, 0% used [0x00000000d8500000,0x00000000d8500000,0x00000000d8a00000)
  to   space 5120K, 0% used [0x00000000d8000000,0x00000000d8000000,0x00000000d8500000)
 ParOldGen       total 87552K, used 0K [0x0000000081e00000, 0x0000000087380000, 0x00000000d5f80000)
  object space 87552K, 0% used [0x0000000081e00000,0x0000000081e00000,0x0000000087380000)
 Metaspace       used 2302K, capacity 4480K, committed 4480K, reserved 1056768K
  class space    used 255K, capacity 384K, committed 384K, reserved 1048576K
```
