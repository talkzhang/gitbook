# 数据类型

| 类型    | 字节 | 位数 |
| ------- | ---- | ---- |
| byte    | 1    | 8    |
| short   | 2    | 16   |
| int     | 4    | 32   |
| long    | 8    | 64   |
| float   | 4    | 32   |
| double  | 8    | 64   |
| char    | 2    | 16   |
| boolean | 1    | 8    |

`boolean类型`被编译为int类型，等于是说JVM里占用字节和int完全一样，int是4个字节，于是boolean也是4字节。 `boolean数组`在Oracle的JVM中，编码为byte数组，每个boolean元素占用8位=1字节。

# 二进制与十进制互转

十进制转二进制

方法为：十进制数除2取余法，即十进制数除2，余数为权位上的数，得到的商值继续除2，依此步骤继续向下运算直到商为0为止。

![十进制转二进制图解](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20210914151526.png)

二进制转十进制

方法为：把二进制数按权展开、相加即得十进制数。

![二进制转十进制图解](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20210914151653.png)

位运算时，右移一位相当于当前值/0.5，左移一位相当于当前值*0.5

# Set常用介绍

常用的有HashSet和TreeSet，通常用HashSet进行去重操作，TreeSet进行排序操作

## TreeSet

TreeSet内部通过TreeMap来进行元素存储，key是元素值，value是一个默认空值，它的排序机制是通过TreeMap来实现的。

TreeSet两种排序方式：

1. 让元素本身具有比较性：元素本身要实现Comparable接口并实现里面的compareTo方法以保证元素本身具有比较性
```java
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

public class Test_treeset {
    public static void main(String[] args) {
            Set<Teacher> ts = new TreeSet<Teacher>();
            ts.add(new Teacher("zhangsan", 1));
            ts.add(new Teacher("lisi", 2));
            ts.add(new Teacher("wangmazi", 3));
            ts.add(new Teacher("wangwu",4));
            ts.add(new Teacher("mazi", 3));
            Iterator<Teacher> it = ts.iterator();
            while (it.hasNext()) {
                System.out.println(it.next());
            }
        }
}
class Teacher implements Comparable {
    int num;
    String name;

    Teacher(String name, int num) {
        this.num = num;
        this.name = name;
    }

    public String toString() {
        return "学号：" + num + "\t\t姓名：" + name;
    }

    //o中存放时的红黑二叉树中的节点，从根节点开始比较
    public int compareTo(Object o) {
        Teacher ss = (Teacher) o;
        //int result = num < ss.num ? 1 : (num == ss.num ? 0 : -1);//降序
        int result = num > ss.num ? 1 : (num == ss.num ? 0 : -1);//升序
        if (result == 0) {
            result = name.compareTo(ss.name);
        }
        return result;
    }
}
```

2. 让容器自身具有比较性：当元素本身不具有比较性或者具备的比较性不是所需要的，就在TreeSet建立实例的时候，传入Comparator接口的实现子类的实例。这个Comparator子类必须实现compare方法。

```java
import java.util.Comparator;
import java.util.Iterator;
import java.util.TreeSet;

public class TreeSetTest {
    public static void main(String[] args) {
        TreeSet<Teacher2> ts = new TreeSet<Teacher2>(new Teacher2.TeacherCompare());
        ts.add(new Teacher2("zhangsan", 2));
        ts.add(new Teacher2("lisi", 1));
        ts.add(new Teacher2("wangmazi", 3));
        ts.add(new Teacher2("mazi", 3));
        Iterator<Teacher2> it = ts.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
}

class Teacher2 {
    int num;
    String name;

    Teacher2(String name, int num) {
        this.num = num;
        this.name = name;
    }

    public String toString() {
        return "学号：" + num + "    姓名：" + name;
    }

    static class TeacherCompare implements Comparator {// 老师自带的一个比较器
        //o1中存放的是目标节点
        //o2中存放时的红黑二叉树中的节点，从根节点开始比较
        public int compare(Object o1, Object o2) {
            Teacher2 s1 = (Teacher2) o1;// 转型
            Teacher2 s2 = (Teacher2) o2;// 转型
            int result = s1.num > s2.num ? 1 : (s1.num == s2.num ? 0 : -1);
            if (result == 0) {
                result = s1.name.compareTo(s2.name);
            }
            return result;
        }
    }
}
```

## hashset使用时为什么必须重新hashcode和equals

因为hashset通过hashMap来实现对对象的插入，hashMap首先会使用hashcode值来确认放入的位置，然后会判断该位置是否有值，如果有的话就会查看该key是否equals，所以肯定要重写这两个方法才能保证key不重复。

# ArrayList、LinkedList、Vector、CopyOnWriteArrayList区别

## ArrayList

底层通过数组来实现，既然是数组，那就需要保证在一个连续的存储空间来进行存储，且数组是需要长度的，它的初始化数组长度为10，随着不断向arrayList内添加元素，当长度不足以容纳现有数据时就会扩容，在进行扩容时，也就是元素超出可容纳长度，会按当前长度的1.5倍进行扩容，当需要扩容时，它会通过copy的方式将旧数组拷贝到一个新数组，所以如果能在实例化ArrayList时就能确认数组的长度，会减免扩容部分消耗的性能；非线程安全，不过大多数场景使用时都是通过new实例来使用；ArrayList因为是通过数组来实现，所以它的查询性能很高，但是插入、删除的效率很低， 因为数组是一块连续的内存空间，比如删除某个元素后数组都需要动态调整它内部元素的数据和位置，ArrayList是通过copy数组来实现的。

## vector
vector和ArrayList比较像，都是通过数组来进行实现，vector最大的特点就是通过 synchronized 来保证多线程情况下的线程安全，synchronized关键字修饰了很多对外暴露的方法，所以在读远大于写的操作场景中，Vector将会发生大量锁竞争，从而给系统带来性能开销。所以在日常开发中这个用的却是不多，毕竟同步是有额外开销的。Vector也可以根据需要自动的增加容量，但是它的扩容倍数默认是当前数组长度的2倍，也是会创建新的数组，并拷贝原有数组数据。该数值可以在初始化Vector时指定调整。

## LinkedList

LinkedList是用链表结构存储数据的，是双向链表的数据结构，它的实现不是数组，而是内部定义的Node节点来实现，每个Node节点保存了上一个节点和下一个节点的位置以及元素本身，因为它的这个特性，所以LinkedList并不需要连续的内存空间，且它最适合插入和删除，但是查找的性能会很差，在查找时LinkedList会根据所需查找的下标和当前数组长度的1/2（index < size>>1）来判断遍历查找，LinkedList内维护了first和last的node节点，每个node内会记录上一个和下一个的Node对象以及当前元素值，所以只要知道一个节点就可以找到元素；如果插入时比如调用add方法，默认就会直接在LinkedList内的last后直接追加一个元素即可，非常高效快速；

## CopyOnWriteArrayList

copyOnWrite，顾名思义，当有写操作时就会进行copy，通过copy来保证多线程场景下执行的安全性，读操作不会进行复制，只有写入、删除会进行复制，复制的流程：比如新增一个元素，就是将原数组copy出来一个新数组，然后添加到新数组里面，最终将原数组的引用指向这个新数组，需要说明的是，copy的过程是需要加锁的，它不像Vector那样有点类似无脑加锁来保证线程安全，而是只有在写入操作才会进行加锁，加锁动作通过ReentrantLock实现，在锁的过程中修改了数组之后，因为这个数组是通过volatile修饰的，所以对读线程立即可见。

CopyOnWriteArrayList 读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。缺点也很明显，一是内存占用问题，每次写入类操作都会对原数组进行copy；二是无法保证强一致性，因为读操作没有锁，写操作有锁，就会发生写操作完成了，但读操作可能还是读的老旧数据的值；

![CopyOnWriteArrayList实现原理图](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20210915113723.png)

# java中的Map

## LinkedHashMap实现原理

LinkedHashMap通过继承hashMap中的Entry ,并添加两个属性Entry before,after,和header结合起来组成一个双向链表，来实现按插入顺序或访问顺序排序。LinkedHashMap通过重写newNode方法，通过此方法保证了插入的顺序性，LinkedHashMap的put方法还是调用的Hashmap的实现，它通过重写newNode来实现插入顺序的排列，它的这个Node是一个双向链表，且在LinkedHashMap内维护了头部节点和尾部节点，在put过程中如果发生了hash碰撞，那就将发生碰撞的节点放至尾部即可。

# 有哪些常见的数据结构

1、数组 2、链表 3、树 4、栈 5、队列 6、哈希 当然还有图和堆

## 树

树是一种非线性数据结构，它是由n个有限节点组成的一个具有层次关系的集合。树的特点如下：

1、每个非根节点只有一个父节点  
2、主根节点只有一个  
3、每个节点都只有有限个子节点或者无子节点

数的种类也很多，有无序树、二叉树，无序树使用的很少，没什么好说的，大概就是说一个树内的所有元素都是无序排列，可能有n多种组合。

### 二叉树

顾名思义，二叉树的特性就是每个节点的子结点不允许超过两个。

二叉树根据它排列的方式，从排列状态上可分为完全二叉树和满二叉树，

完全二叉树：比如一颗树高度为n，除n层外其他所有层级节点数目都已达到最大值，且第n层的节点都从左向右紧密排列，这种排列状态就是完全二叉树。

满二叉树：就是一棵树的所有节点都已达到最大值

需要重点提的，还是二叉查找树（Binary Search Tree，简称BST），二叉查找树的特点就是一个主节点，比它小的永远在左子节点，比它大的永远在右边子节点，它的有点就是理想状态，注意只是理想状态下要比链表的查找速度快，但是它的插入和删除相比链表来讲还是要更复杂一些，所以二叉树综合下来可以说是既有链表的好处，也有数组的好处。

二叉查找树示例：

![二叉查找树图示](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20210916183139.png)

图中这么多节点，如果是链表的话就是节点个数的长度，而二叉树可以有效的降低这种长度，提高查询效率。

但是这只是理想状态下，二叉查找树比较依赖于数值的插入顺序，如果极端情况下顺序并不是理想中的那样，可能会出现如下情况：

![二叉查找树极端情况](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20210916183438.png)

如果出现这种极端情况，那就和链表没什么区别了，还用什么二叉树呢，所以说，它的高度决定了它的查找效率。

总结一下，二叉树的优点就是可以有效减少查询的复杂度，但是它的高度决定了它的查找效率，它的高效实现还是要依赖元素插入的顺序，在极端情况下会出现元素个数=元素高度，反而影响了效率。

所以为了解决这种现象，有人就提出一个平衡二叉树的概念，java中HashMap的红黑树就是一个典型的平衡二叉树的实现。

什么是红黑树？

红黑树简单来说就是在二叉查找树基础上增加了颜色的概念，红色和黑色。所有红黑树都有以下特点：

1. 任何一个节点都有颜色，黑色或者红色。
2. 根节点是黑色的。
3. 父子节点之间不能出现两个连续的红节点。
4. 任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。
5. 空节点被认为是黑色的。

红黑树是通过动态调整来保证了整个树的高度平衡，动态调整有可能只是调一下颜色，也有可能通过左旋或者右旋发生根节点变化，所有插入的新节点都是红色，root根节点肯定是黑色，根据上面红黑树的特性来进行调整，最终会保持整颗树的平衡（logN)

那么问题来了，既然实现了平衡，它的优点很明显，就是提高查询效率，比如1000000个节点，只需要查找20次就可以找到，但是这种平衡是需要付出一定的代价，那就是在插入和删除时动态维护整颗树的平衡，红黑树是实现较好的平衡二叉树，通过颜色+自旋可以高效实现平衡二叉树。

详情看数据结构：https://tech.meituan.com/2016/12/02/redblack-tree.html

# Integer是引用传递还是值传递

理论上Integer作为一个封装对象应该是引用传递，但是Integer内部的value属性是final，这意味着虽然它是一个对象，但是也是值传递。

详见链接：https://blog.csdn.net/WitsMakeMen/article/details/46874717

# logN举例说明

![logN举例说明](https://gitee.com/hongqigg/imgs-bed/raw/master/image/20210915184304.png)

# 阻塞队列和非阻塞队列

队列的特点是先进先出

至于队列的操作常用方法，[请移步这里](https://talkzhang.gitbook.io/learndoc/java/ji-chu-zhi-shi/dui-lie-he-zhan)

阻塞队列与普通队列的区别在于，当队列是空的时，从队列中获取元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程使队列重新变得空闲起来，如从队列中移除一个或者多个元素，或者完全清空队列。

## 阻塞队列

### ArrayBlockingQueue

从名称就可以看出来，该队列是通过数组来实现的，也就是说内部维护了一个数组，且可指定长度，所以是阻塞且有界的一个队列，并且可以指定公平性和非公平性，默认情况下为非公平的，即不保证等待时间最长的线程最优先能够访问队列，它的公平与非公平实现用的是ReentrantLock，ReentrantLock本身的功能是有支持公平锁和非公平锁的

### LinkedBlockingQueue

基于单向链表实现的可有界队列，为什么说可有界，因为构造该队列时可以指定长度，也可以不指定，如果不指定，默认容量就是Integer.MAX_VALUE

### PriorityBlockingQueue

支持优先级的阻塞队列；